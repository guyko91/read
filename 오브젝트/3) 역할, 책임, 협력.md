* 객체지향 패러다임의 관점에서 핵심은 역할(role), 책임(responsibility), 협력(collaboration) 이다.
* 클래스, 상속, 지연 바인딩 등의 개념은 구현 측면에 치우쳐 있기 때문에 객체지향 패러다임 본질과는 거리가 있다. (중요하지 않다는 것은 아니다.)

> [! note] 객체지향의 본질
> 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다.
> 클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.
> 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.


## 협력
* 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적인 존재다.
* 협력이란, 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다.
	* 요청은 **메시지** 전송(message sending)을 통해 이루어진다. (유일한 커뮤니케이션 수단)
* 메시지를 수신한 객체는 **메서드** 를 실행해 요청에 응답한다.
* 요청 객체는 단지 요구사항을 메시지로 전송할 뿐이며, 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.

> 객체를 자율적인 존재로 만드는 가장 기본적인 방법은 **캡슐화** 하는 것이다.

* 객체의 상태(field)와 행동(method)
	* 상태 : 객체가 행동하는 데 필요한 정보에 의해 결정된다. 
	* 행동 : 협력 안에서 객체가 처리한 메시지로 결정된다.
	* 협력은 객체를 설계하는 데 필요한 일종의 **문맥**(context)을 제공한다.

## 책임

> 책임이란, 협력에 참여하기 위해 객체가 수행하는 행동을 말한다.

> [! note] 객체의 책임
> 객체에 의해 정의되는 응집도 있는 행위의 집합.
> 객체가 '무엇을 알고 있는가'와 '무엇을 할 수 있는가'로 구성된다.
> 객체의 책임은 크게 '하는 것(doing)'과 '아는 것(knowing)' 범주로 나뉜다.

* 하는 것(doing)
	* 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
	* 다른 객체의 행동을 시작시키는 것
	* 다른 객체의 활동을 제어하고 조절하는 것
* 아는 것(knowing)
	* 사적인 정보에 관해 아는 것
	* 관련된 객체에 관해 아는 것
	* 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

* 객체의 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로도 더 큰 개념이다.
* 책임을 능숙하게 소프트웨어 객체에 할당하는 것이 객체지향 개발에서 가장 중요한 능력이다.

> [! note] 책임을 할당할 때 고려해야할 요소
> 1. 메시지가 객체를 결정한다.
> 	1. 객체가 메시지를 결정하는게 아니라, 메시지가 객체를 결정한다.
> 		1. 객체가 최소한의 인터페이스를 가질 수 있게 된다.
> 		2. 추상적인 인터페이스를 가질 수 있게 된다.
> 2. 행동이 상태를 결정한다. 
> 	객체를 객체답게 만드는 것은 객체의 상태가 아니라 다른 객체에게 제공하는 '행동'이다
> 	개별 객체의 상태와 행동이 아닌 시스템 구현을 위한 '협력'에 초점을 맞춰야 응집도가 높고 결합도가 낮은 객체들을 창조할 수 있다.


## 역할

> 객체가 어떤 특정한 '협력' 안에서 수행하는 '책임'의 '집합'을 **역할** 이라고 한다.

* 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다.
* 역할을 이용하면 불필요한 중복 코드를 제거할 수 있다.

> [! note] 역할의 구현
> 역할을 구현하는 가장 일반적인 방법은 '추상 클래스'와 '인터페이스'를 사용하는 것이다.
> 추상클래스 : 책임의 일부를 구현해놓은 것
> 인터페이스 : 일체의 구현 없이 책임의 집합 (역할)만 나열해 놓은 것


> [! note] 객체지향 설계란
> 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.